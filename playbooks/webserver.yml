---
- hosts: localhost
  gather_facts: false

  vars:
    # Name/namespace from the WebServer CR
    webserver_name: "{{ ansible_operator_meta.name }}"
    webserver_ns:   "{{ ansible_operator_meta.namespace }}"

    #################################################################
    # FIX: In your runtime, the top-level `spec` variable is {}.
    # So we derive spec from the full CR object when available.
    #################################################################

    # The full CR object is exposed under different variable names
    # depending on scaffold/version. Try a safe fallback chain.
    cr_obj: >-
      {{
        ansible_operator_resource
        | default(resource, true)
        | default(meta, true)
        | default({}, true)
      }}

    # Extract spec from the CR object; fall back to the old `spec` var if present
    spec_obj: >-
      {{
        (cr_obj.get('spec', {})
          if (cr_obj is mapping and (cr_obj.get('spec', None) is not none))
          else (spec | default({})))
      }}

    # Normalize type for robust comparison (handles whitespace/casing)
    server_type_raw: "{{ spec_obj.get('type', 'nginx') }}"
    server_type:     "{{ server_type_raw | string | lower | trim }}"

    # Raw values from the CR spec (cast later when we build the manifest)
    replicas:       "{{ spec_obj.get('replicas', 1) }}"
    container_port: "{{ spec_obj.get('port', 8080) }}"

    # Default images (OpenShift-friendly)
    nginx_image_default:  "nginxinc/nginx-unprivileged:stable-alpine"
    apache_image_default: "registry.access.redhat.com/ubi8/httpd-24"

  tasks:
    #################################################################
    # Detect delete vs normal reconcile
    #################################################################
    - name: Detect if WebServer CR is being deleted
      set_fact:
        being_deleted: >-
          {{ ansible_operator_meta.deletion_timestamp is defined
             and (ansible_operator_meta.deletion_timestamp | string | length) > 0 }}

    #################################################################
    # Labels (create/update only)
    #################################################################
    - name: Set labels (create/update only)
      set_fact:
        labels:
          app.kubernetes.io/name: "{{ webserver_name }}"
          app.kubernetes.io/instance: "{{ webserver_name }}"
          app.kubernetes.io/managed-by: "webserver-operator"
          app: "{{ webserver_name }}"
      when: not being_deleted

    #################################################################
    # CREATE / UPDATE PATH
    #################################################################
    - block:
        #################################################################
        # DEBUG: prove what variables exist + what spec we extracted
        #################################################################
        - name: DEBUG - which CR vars exist + spec extracted
          debug:
            msg:
              - "CR: {{ webserver_name }} (ns={{ webserver_ns }})"
              - "has ansible_operator_resource={{ ansible_operator_resource is defined }}"
              - "has resource={{ resource is defined }}"
              - "has meta={{ meta is defined }}"
              - "top-level spec var={{ spec | default('<undefined>') }}"
              - "cr_obj type={{ cr_obj | type_debug }}"
              - "cr_obj keys={{ (cr_obj.keys() | list) if (cr_obj is mapping) else '<not a mapping>' }}"
              - "spec_obj (full)={{ spec_obj }}"
              - "spec.type raw={{ server_type_raw }}"
              - "server_type normalized={{ server_type }}"

        #################################################################
        # Validate server_type is supported (do not silently fall back)
        #################################################################
        - name: Validate server_type is supported
          fail:
            msg: >-
              Unsupported spec.type='{{ server_type_raw }}' (normalized='{{ server_type }}').
              Must be one of: nginx, apache
          when: server_type not in ['nginx', 'apache', 'httpd']

        #################################################################
        # Compute desired container image/name
        #################################################################
        - name: Determine default image for server type
          set_fact:
            default_image: "{{ apache_image_default if server_type in ['apache', 'httpd'] else nginx_image_default }}"

        - name: Pick final container image (allow explicit override via spec.image)
          set_fact:
            container_image: >-
              {{ (
                  spec_obj.get('image', '')
                  if (spec_obj.get('image', '') | string | trim | length > 0)
                  else default_image
                ) | trim }}

        - name: Set container name
          set_fact:
            container_name: "{{ 'apache' if server_type in ['apache', 'httpd'] else 'nginx' }}"

        - name: DEBUG - computed desired container values
          debug:
            msg:
              - "desired container_name={{ container_name }}"
              - "desired container_image={{ container_image }}"
              - "desired replicas={{ replicas | int }}"
              - "desired container_port={{ container_port | int }}"

        #################################################################
        # DEBUG: read current Deployment (if it exists) so we can compare
        #################################################################
        - name: Get existing Deployment (if any)
          k8s_info:
            api_version: apps/v1
            kind: Deployment
            namespace: "{{ webserver_ns }}"
            name: "{{ webserver_name }}"
          register: existing_deploy
          failed_when: false

        - name: DEBUG - existing Deployment container (if present)
          debug:
            msg: >-
              existing container={{ (existing_deploy.resources[0].spec.template.spec.containers[0].name
                if (existing_deploy.resources | default([]) | length) > 0 else '<none>') }},
              image={{ (existing_deploy.resources[0].spec.template.spec.containers[0].image
                if (existing_deploy.resources | default([]) | length) > 0 else '<none>') }}
          when: existing_deploy is defined

        #################################################################
        # Build Deployment via YAML + from_yaml (ensures ints, not strings)
        #################################################################
        - name: Build Deployment manifest as YAML
          set_fact:
            deployment_manifest_yaml: |
              apiVersion: apps/v1
              kind: Deployment
              metadata:
                name: {{ webserver_name }}
                namespace: {{ webserver_ns }}
                labels: {{ labels | to_json }}
              spec:
                replicas: {{ replicas | int }}
                selector:
                  matchLabels:
                    app: {{ webserver_name }}
                template:
                  metadata:
                    labels: {{ labels | to_json }}
                  spec:
                    containers:
                      - name: {{ container_name }}
                        image: {{ container_image }}
                        ports:
                          - name: http
                            containerPort: {{ container_port | int }}
                        readinessProbe:
                          httpGet:
                            path: /
                            port: http
                          initialDelaySeconds: 5
                          periodSeconds: 10
                        livenessProbe:
                          httpGet:
                            path: /
                            port: http
                          initialDelaySeconds: 10
                          periodSeconds: 20

        - name: Parse Deployment YAML into dict
          set_fact:
            deployment_definition: "{{ deployment_manifest_yaml | from_yaml }}"

        #################################################################
        # Apply Deployment (force helps ensure spec updates are pushed)
        #################################################################
        - name: Ensure Deployment exists for selected web server (force apply)
          k8s:
            state: present
            definition: "{{ deployment_definition }}"
            force: true

        #################################################################
        # Re-read Deployment after apply and verify it matches desired state
        #################################################################
        - name: Get Deployment after apply
          k8s_info:
            api_version: apps/v1
            kind: Deployment
            namespace: "{{ webserver_ns }}"
            name: "{{ webserver_name }}"
          register: applied_deploy

        - name: DEBUG - applied Deployment container
          debug:
            msg:
              - "applied container_name={{ applied_deploy.resources[0].spec.template.spec.containers[0].name }}"
              - "applied container_image={{ applied_deploy.resources[0].spec.template.spec.containers[0].image }}"

        - name: FAIL if applied Deployment does not match desired server type
          fail:
            msg: >-
              Reconcile mismatch: spec.type='{{ server_type }}' requested, but Deployment is still
              container='{{ applied_deploy.resources[0].spec.template.spec.containers[0].name }}'
              image='{{ applied_deploy.resources[0].spec.template.spec.containers[0].image }}'
          when: >
            (server_type in ['apache','httpd'] and applied_deploy.resources[0].spec.template.spec.containers[0].name != 'apache')
            or
            (server_type == 'nginx' and applied_deploy.resources[0].spec.template.spec.containers[0].name != 'nginx')

        #################################################################
        # Service
        #################################################################
        - name: Ensure Service exists
          k8s:
            state: present
            definition:
              apiVersion: v1
              kind: Service
              metadata:
                name: "{{ webserver_name }}"
                namespace: "{{ webserver_ns }}"
                labels: "{{ labels }}"
              spec:
                selector:
                  app: "{{ webserver_name }}"
                ports:
                  - name: http
                    port: 80
                    targetPort: http
                    protocol: TCP

        #################################################################
        # Route
        #################################################################
        - name: Ensure Route exists
          k8s:
            state: present
            definition:
              apiVersion: route.openshift.io/v1
              kind: Route
              metadata:
                name: "{{ webserver_name }}"
                namespace: "{{ webserver_ns }}"
                labels: "{{ labels }}"
              spec:
                to:
                  kind: Service
                  name: "{{ webserver_name }}"
                port:
                  targetPort: http
                tls:
                  termination: edge

        #################################################################
        # Status
        #################################################################
        - name: Set status to Ready
          operator_sdk.util.k8s_status:
            api_version: example.com/v1alpha1
            kind: WebServer
            name: "{{ webserver_name }}"
            namespace: "{{ webserver_ns }}"
            status:
              phase: Ready
              message: >-
                Deployed {{ container_name }} using image {{ container_image }}
                with {{ replicas | int }} replica(s) on port {{ container_port | int }}

      when: not being_deleted
