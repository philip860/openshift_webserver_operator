---
- hosts: localhost
  gather_facts: false

  vars:
    webserver_name: "{{ ansible_operator_meta.name }}"
    webserver_ns:   "{{ ansible_operator_meta.namespace }}"

    # Normalize type to lowercase for consistent comparison
    server_type:    "{{ (spec.type | default('nginx')) | lower | trim }}"

    # Raw values from the CR spec (cast to int later in the manifest)
    replicas:       "{{ spec.replicas | default(1) }}"
    # For UBI nginx/httpd, 8080 is a common non-root listen port; you can
    # adjust or drive this from the CR
    container_port: "{{ spec.port | default(8080) }}"

    # OpenShift-friendly default images (UBI-based)
    # These are designed to run as non-root on OpenShift with restricted SCC.
    nginx_image_default:  "registry.access.redhat.com/ubi8/nginx-120"
    apache_image_default: "registry.access.redhat.com/ubi8/httpd-24"

  tasks:
    #################################################################
    # Compute labels and pick image
    #################################################################

    - name: Set labels for this WebServer
      set_fact:
        labels:
          app.kubernetes.io/name: "{{ webserver_name }}"
          app.kubernetes.io/instance: "{{ webserver_name }}"
          app.kubernetes.io/managed-by: "webserver-operator"
          app: "{{ webserver_name }}"

    - name: Determine default image for server type (nginx vs httpd/apache)
      set_fact:
        default_image: >-
          {{ apache_image_default if server_type in ['apache', 'httpd']
             else nginx_image_default }}

    - name: Pick final container image (spec.image override, else default)
      set_fact:
        container_image: >-
          {{ (
              spec.image
              if (
                   spec is defined
                   and spec.image is defined
                   and (spec.image | string | trim | length > 0)
                 )
              else default_image
            ) | trim }}

    #################################################################
    # Build Deployment via YAML + from_yaml (ensures ints, not strings)
    #################################################################

    - name: Build Deployment manifest as YAML
      set_fact:
        deployment_manifest_yaml: |
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: {{ webserver_name }}
            namespace: {{ webserver_ns }}
            labels: {{ labels | to_json }}
          spec:
            replicas: {{ replicas | int }}
            selector:
              matchLabels:
                app: {{ webserver_name }}
            template:
              metadata:
                labels: {{ labels | to_json }}
              spec:
                restartPolicy: Always
                containers:
                  - name: {{ server_type }}
                    image: {{ container_image }}
                    # Let the UBI images use their default command/entrypoint.
                    # They are built to work with OpenShift (non-root).
                    ports:
                      - name: http
                        containerPort: {{ container_port | int }}
                    # TCP probes: only check that the port is open
                    readinessProbe:
                      tcpSocket:
                        port: {{ container_port | int }}
                      initialDelaySeconds: 5
                      periodSeconds: 10
                    livenessProbe:
                      tcpSocket:
                        port: {{ container_port | int }}
                      initialDelaySeconds: 10
                      periodSeconds: 20

    - name: Parse Deployment YAML into dict
      set_fact:
        deployment_definition: "{{ deployment_manifest_yaml | from_yaml }}"

    #################################################################
    # Ensure child resources exist
    #################################################################

    - name: Ensure Deployment exists for selected web server
      k8s:
        state: present
        definition: "{{ deployment_definition }}"

    - name: Ensure Service exists
      k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Service
          metadata:
            name: "{{ webserver_name }}"
            namespace: "{{ webserver_ns }}"
            labels: "{{ labels }}"
          spec:
            selector:
              app: "{{ webserver_name }}"
            ports:
              - name: http
                port: 80
                targetPort: http
                protocol: TCP

    - name: Ensure Route exists
      k8s:
        state: present
        definition:
          apiVersion: route.openshift.io/v1
          kind: Route
          metadata:
            name: "{{ webserver_name }}"
            namespace: "{{ webserver_ns }}"
            labels: "{{ labels }}"
          spec:
            to:
              kind: Service
              name: "{{ webserver_name }}"
            port:
              targetPort: http
            tls:
              termination: edge

    #################################################################
    # Update CR status
    #################################################################

    - name: Set status to Ready
      operator_sdk.util.k8s_status:
        api_version: example.com/v1alpha1
        kind: WebServer
        name: "{{ webserver_name }}"
        namespace: "{{ webserver_ns }}"
        status:
          phase: Ready
          message: >-
            Deployed {{ server_type }} using image {{ container_image }}
            with {{ replicas }} replica(s) on port {{ container_port }}
